#include <stdio.h>
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;


#define Nk 4
#define Nb 4
#define Nr 10


// Définitions des tableaux globaux
u32 Rcon[10] = {
	0x01000000,
	0x02000000,
	0x04000000,
	0x08000000,
	0x10000000,
	0x20000000,
	0x40000000,
	0x80000000,
	0x1B000000,
	0x36000000
};

u8 s_box[16][16] = {
	{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76},
	{0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0},
	{0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15},
	{0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75},
	{0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84},
	{0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf},
	{0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8},
	{0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2},
	{0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73},
	{0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb},
	{0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79},
	{0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08},
	{0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a},
	{0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e},
	{0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf},
	{0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}
};

u8 inv_s_box[16][16] = {
	{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb},
	{0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb},
	{0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e},
	{0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25},
	{0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92},
	{0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84},
	{0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06},
	{0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b},
	{0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73},
	{0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e},
	{0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b},
	{0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4},
	{0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f},
	{0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef},
	{0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61},
	{0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d}
};

#include <stdint.h>

u32 sub_key[] = {
    0xA0FAFE17, // i = 4
    0x88542CB1, // i = 5
    0x23A33939, // i = 6
    0x2A6C7605, // i = 7
    0xF2C295F2, // i = 8
    0x7A96B943, // i = 9
    0x5935807A, // i = 10
    0x7359F67F, // i = 11
    0x3D80477D, // i = 12
    0x4716FE3E, // i = 13
    0x1E237E44, // i = 14
    0x6D7A883B, // i = 15
    0xEF44A541, // i = 16
    0xA8525B7F, // i = 17
    0xB671253B, // i = 18
    0xDB0BAD00, // i = 19
    0xD4D1C6F8, // i = 20
    0x7C839D87, // i = 21
    0xCAF2B8BC, // i = 22
    0x11F915BC, // i = 23
    0x6D88A37A, // i = 24
    0x110B3EFD, // i = 25
    0xDBF98641, // i = 26
    0xCA0093FD, // i = 27
    0x4E54F70E, // i = 28
    0x5F5FC9F3, // i = 29
    0x84A64FB2, // i = 30
    0x4EA6DC4F, // i = 31
    0xEAD27321, // i = 32
    0xB58DBAD2, // i = 33
    0x312BF560, // i = 34
    0x7F8D292F, // i = 35
    0xAC7766F3, // i = 36
    0x19FADC21, // i = 37
    0x28D12941, // i = 38
    0x575C006E, // i = 39
    0xD014F9A8, // i = 40
    0xC9EE2589, // i = 41
    0xE13F0CC8, // i = 42
    0xB6630CA6  // i = 43
};
// Les types et macros sont maintenant dans integration.h
// Les tableaux sont dans aes_data.c

void display_inout(char *str, u8 array[16])
{
	u8 i;
	printf("%s", str);
	for (i=0; i<16; i++)
	  printf("0x%02X ", array[i]);
	printf("\n\n");  
}

void input2state(u8 input[16], u8 state[4][4])
{
	u8 r,c;
    for (c=0; c<4; c++)
	  for (r=0; r<4; r++)
	    state[r][c] = input[r+4*c];
}

void state2output(u8 state[4][4], u8 output[16])
{
	u8 r,c;
    for (c=0; c<4; c++)
	  for (r=0; r<4; r++)
	    output[r+4*c] = state[r][c];
}

void copy_state(u8 state_in[4][4], u8 state_out[4][4])
{
	u8 r,c;
    for (c=0; c<4; c++)
	  for (r=0; r<4; r++)
	    state_out[r][c] = state_in[r][c];
}

void display_state(u8 state[4][4])
{
	u8 r;
	for (r=0; r<4; r++)
	  printf("0x%02X 0x%02X 0x%02X 0x%02X\n", state[r][0], state[r][1], state[r][2], state[r][3]);
}


/// ___________________________________________________________________________ ///

//void ShiftRows(u8 in_state[4][4], u8 out_state[4][4])
//{}
void InvSubBytes(u8 in_state[4][4], u8 out_state[4][4])
{}
void InvShiftRows(u8 in_state[4][4], u8 out_state[4][4])
{}
//void AddRoundKey(u8 in_state[4][4], u32 sub_key[4], u8 out_state[4][4])
//{}
u8 GF256_mult(u8 a, u8 b)
{}
void MixColumns(u8 in_state[4][4], u8 out_state[4][4])
{}
void SubBytes(u8 in_state[4][4], u8 out_state[4][4])
{}
//u32 RotWord(u32 in_word)
//{}
// u32 SubWord(u32 in_word)
// {}
// void KeyExpansion(u8 key[4*Nk], u32 w[Nb*(Nr+1)])
// {}

void ShiftRows(u8 in_state[4][4],u8 out_state[4][4])
{
    u8 shift;
    for(u8 i=0;i<4;i++){
        for(u8 j=0;j<4;j++){
            shift=i+j;
            if(shift>=4){
                shift=shift-4;
            }
            out_state[i][j]=in_state[i][shift];
        }
    }
}

void AddRoundKey(u8 in_state[4][4], u32 sub_key[4], u8 out_state[4][4])
{
    u8 c;
    for (c = 0; c < 4; c++) {
        out_state[0][c] = in_state[0][c] ^ (u8)(sub_key[c] >> 24);
        out_state[1][c] = in_state[1][c] ^ (u8)(sub_key[c] >> 16);
        out_state[2][c] = in_state[2][c] ^ (u8)(sub_key[c] >>  8);
        out_state[3][c] = in_state[3][c] ^ (u8)(sub_key[c] >>  0);

    };
}

u32 word(u8 b0, u8 b1, u8 b2, u8 b3)
{
    return ((u32)b0 << 24) | ((u32)b1 << 16) | ((u32)b2 << 8) | (u32)b3;
}

u32 RotWord(u32 t)
{
    return (t << 8) | (t >> 24);
}
u32 SubWord(u32 t)
{
    u8 b0 = (u8)(t >> 24);
    u8 b1 = (u8)(t >> 16);
    u8 b2 = (u8)(t >> 8);
    u8 b3 = (u8)(t);

    u8 x, y;

    x = (u8)(b0 >> 4); y = (u8)(b0 & 0x0F); b0 = s_box[x][y];
    x = (u8)(b1 >> 4); y = (u8)(b1 & 0x0F); b1 = s_box[x][y];
    x = (u8)(b2 >> 4); y = (u8)(b2 & 0x0F); b2 = s_box[x][y];
    x = (u8)(b3 >> 4); y = (u8)(b3 & 0x0F); b3 = s_box[x][y];

    return word(b0, b1, b2, b3);
}


void KeyExpansion(u8 key[4*Nk], u32 w[Nb*(Nr+1)])
{
    u32 temp;
    u32 i = 0;

    while (i < Nk) {
        w[i] = word(key[4i], key[4i + 1], key[4i + 2], key[4i + 3]);
        i = i + 1;
    }

    i = Nk;


    while (i < (Nb * (Nr + 1))) {
        temp = w[i - 1];

        if ((i % Nk) == 0) {

            temp = SubWord(RotWord(temp)) ^ Rcon[(i / Nk) - 1];
        }
        else if ((Nk > 6) && ((i % Nk) == 4)) {

            temp = SubWord(temp);
        }

        w[i] = w[i - Nk] ^ temp;
        i = i + 1;
    }
}

u8 xtime(u8 A){
    u8 res;
    if(A & (1<<7)){
        res = (A<<1) ^ 0x1b;
    } else {
        res = (A<<1);
    }
    return res;
}

u8 gf256_mult(u8 a, u8 b)
{
    u8 tmp = 0;
    u8 tabXtime[8];

    tabXtime[0] = a;
    for(u32 i = 1 ; i < 8 ; i++){
        tabXtime[i] = xtime(tabXtime[i-1]);
    }

    for(u32 i = 0 ; i < 8 ; i++){
      if(b & (1 << i)){
        tmp ^= tabXtime[i];
      }
    }
    return tmp;
}

/// ___________________________________________________________________________ ///

void Cipher(u8 in[4*Nb], u8 out[4*Nb], u32 w[Nb*(Nr+1)]) {
    u8 state[4][Nb];
	u8 state_out[4][Nb];

    input2state(in, state);
    
    printf("\n╔════════════════════════════════════════════════════════════╗\n");
    printf("║                    AES CIPHER PROCESS                      ║\n");
    printf("╚════════════════════════════════════════════════════════════╝\n\n");
    
    printf("┌─ Round 0: Initial AddRoundKey\n");
    AddRoundKey(state, &w[0], state_out);
	copy_state(state_out, state);
	display_state(state);
	printf("\n");
	
    for (int round = 1; round < (Nr-1); round++)
    {
        printf("┌─ Round %d/%d ───────────────────────────────────────────────\n", round, Nr);
        
        SubBytes(state, state_out);
		copy_state(state_out, state);
		printf("│  ├─ After SubBytes:\n");
		display_state(state);
		
        ShiftRows(state, state_out);
		copy_state(state_out, state);
		printf("│  ├─ After ShiftRows:\n");
		display_state(state);
		
        MixColumns(state, state_out);
		copy_state(state_out, state);
		printf("│  ├─ After MixColumns:\n");
		display_state(state);
		
        AddRoundKey(state, &w[round*4], state_out);
		copy_state(state_out, state);
		printf("│  └─ After AddRoundKey:\n");
		display_state(state);
		printf("└────────────────────────────────────────────────────────────\n\n");
    }
    
    printf("┌─ Final Round %d/%d ─────────────────────────────────────────\n", Nr, Nr);
    SubBytes(state, state_out);
	copy_state(state_out, state);
	printf("│  ├─ After SubBytes:\n");
	display_state(state);
	
    ShiftRows(state, state_out);
	copy_state(state_out, state);
	printf("│  ├─ After ShiftRows:\n");
	display_state(state);
	
    AddRoundKey(state, &w[Nr*Nb], state_out);
    printf("│  └─ After AddRoundKey (Final):\n");
	display_state(state_out);
	printf("└────────────────────────────────────────────────────────────\n\n");
	
    state2output(state_out, out);

}

void InvCipher(u8 in[4*Nb], u8 out[4*Nb], u32 sub_key[Nb*(Nr+1)]) {

}

/// ___________________________________________________________________________ ///

int main(void)
{
  u8 input[16] = {0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34};
  u8 key[16]   = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};

  //u8 input[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
  //u8 key[16]   = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};

  u8 ciphered[16];
  u8 plained[16];
  
  KeyExpansion(key,sub_key);
  
  display_inout("input = \0", input);

  Cipher(input, ciphered, sub_key);    
  display_inout("ciphered = \0", ciphered);
  
  InvCipher(ciphered, plained, sub_key);    
  display_inout("plained = \0", plained);
  
  return 0;
}

		 
